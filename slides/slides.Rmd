---
title: "Rbootcamp/Workshop"
author: "Michael Kleinsasser"
date: "8/27/2019"
output: 
    beamer_presentation:
      theme: "CambridgeUS"
      colortheme: "dolphin"
      fonttheme: "structurebold"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


## Mike's Personal Introduction

\begin{columns}[T] % align columns
\begin{column}{.48\textwidth}

\begin{itemize}
\setlength\itemsep{1em}

\item R programmer for the Department of Biostatistics

\item Write and mantain R packages for faculty and students

\item Consult faculty and students on writing R packages, optimization

\end{itemize}


\end{column}%
\hfill%
\begin{column}{.48\textwidth}

\includegraphics[width = 2in]{personal_picture.jpg}

\end{column}%
\end{columns}


## Rbootcamp Introduction

Goals (roughly):

 - Day 1: Setting up and using R interactively, syntax and data types, creating viewing and removing objects, on-line help, writing functions, how most statistical procedures are implemented in R
 
 - Day 2: Non-interactive R and the cluster. How to write optimized code, including vectorization and loops, and introduction to data manipulation with dplyr, and visualization with ggplot2
 
 - Day 3: Finally we combine our knowledge and apply it to a series of simulation problems


## Materials

- All bootcamp materials online at https://github.com/umich-biostatistcs/Rbootcamp

  - Handouts with examples to work through

  - R scripts of our examples (.Rmd slides, .R scripts)

- Go to link and download zip archive, extract

## Setup

Go to Rstudio cloud to follow along:

- Enter username, etc. for free account

- Follow along by typing commands in my slides

- If you have Rstudio/R, open that

- Recommended: Install R/Rstudio for days 2, 3

- See course materials for download instructions

## R Basics: Big Picture

 - R is a sophisticated calculator for statistics

Chambers (2016) Extending R:

 - Everything that exists in R is an object
 - Everything that happens in R is a function call
 
Obtain a basic working knowledge of R objects and functions, 

 - Google the rest!
 
## R Basics: a basic schematic view

\includegraphics[width = 4.5in]{R_schemtic.JPG}

## R Basics: Goals

- Data types and functions
\smallskip 
  - Create object having data types
  - Combine those into data structures
  - Write basic R function

\medskip

- Learn parts of R most useful to statisticians
\smallskip 
  - How do most modeling functions work in R, and
  - How to inspect structure and content of objects
  - Data manipulation and visualization
  
\medskip

- Apply knowledge to simulation
\smallskip 
  - Set up, draw from various distributions
  - Summarise, visualize
  
## Ways to run R

Either "interactively" or "non-interactively"

 - Interactive R: 
 - For line by line code execution 
 - Open the Rgui.exe or 
 - Open Rstudio.exe (recommended) - integrated developement environment for R
 
Non-interactively:

 - For running entire scripts at once
 - Desired for allocating large jobs on the cluster (return to later)
  
## Use R as a calculator

Standard operations: 

```{r , echo = TRUE}
# multiply *, divide /, add + subtract - 
18056.983 - 1005.118 + 22.53

( (pi - 3.14) / (3.14) )  * 100
```

\includegraphics[width = 2in]{calculator.JPG}


## Operators: arithmetic and logical

\begin{columns}[T] % align columns
\begin{column}{.48\textwidth}

\begin{table}
\begin{tabular}{l | l}
Operator & Description \\
\hline \hline
$+$ & addition \\ 
$-$ & subtraction \\ 
$/$ & division \\ 
\string^ & exponential \\ 
\%\% & modulus (x mod y) \\ 
\%/\% & integer division
\end{tabular}
\caption{Arithmetic Operators}
\end{table}


\end{column}%
\hfill%
\begin{column}{.48\textwidth}

\begin{table}
\begin{tabular}{l | l}
Operator & Description \\
\hline \hline
< & less than \\ 
<= & less than or equal \\
\string> & greater than \\
\string>= & greater than or equal \\
== & exactly equal to \\
!= & not equal to \\
!x & not x (x logical) \\
x|y & x OR y \\
x\&y & x AND y \\
isTRUE(x) & is x TRUE 
\end{tabular}
\caption{Logical Operators}
\end{table}

\end{column}%
\end{columns}


## Operators: an example

Test if these two expressions are equivalent in R:

```{r, echo=TRUE, eval=FALSE}
A = c(TRUE, TRUE, FALSE); B = c(FALSE, FALSE, TRUE)
# Expression 1:
A | B

# Expression 2: 
!(A == B)

# test equality:
all.equal(A | B, !(A == B))
```

## Operators and vectorization

Arithmetic/logical operators are \textbf{vectorized}:

Given these vectors:
```{r, eval=TRUE}
x = c(1,2,3); y = c(4,8,16) #; emp = c(T,F,F,T); ret = c(T,T,T,F)
x; y; # emp; ret
```

```{r, echo=TRUE}
x + y
x * y
y <= x
```



## Create, list, delete objects

Create object with "assign" operator

 - arrow then minus sign  <-
 - single equal sign      =

```{r asignment, echo = TRUE}
# x gets the number 3.14
x <- 3.14
x     # print x

# equivalently
x = 3.14
x     # print x
```


## Create, list, delete objects

Objects we create are stored in memory, e.g.:

```{r, echo = TRUE}
name = "Carmen"
n1 = 10
n2 = 100
m = 0.5
```


Use ls() function to list all objects in memory:

```{r, echo = TRUE}
ls()
```

Notice: I created x before, it's still in memory.

## Create, list, delete objects

Use ls() function to list all objects in memory:

```{r, echo = TRUE}
ls()
```

The function ls.str() displays some details about objects in memory:

```{r,echo=TRUE}
ls.str()
```

## Create, list, delete objects

To delete objects in memory, use rm() function

```{r, echo = TRUE}
rm(x) # delets object named x
ls()  # which objects remain in memory?
rm(m, n2, name) # remove multiple objects
ls()
rm(list = ls()) # remove everything from memory
ls()
```

## The on-line help

R has structured help pages providing "how-to"

 - \textbf{Description:} what function does
 - \textbf{Usage:} name with arguments and options
 - \textbf{Arguments:} how each argument should be structured
 - \textbf{Details:} more detailed description
 - \textbf{Value:} How the output is structured/ what it contains
 - \textbf{Examples:} examples of the function in use
 
```{r, echo = TRUE, eval = FALSE}
?rm          # help documentation for rm function
help("rm")   # alternately
```

## The on-line help

\includegraphics[width = 4in]{help_doc.JPG}

## Other R help

Many package writers create Vignettes and READMEs

How to view vignettes?

```{r, echo = TRUE, eval = FALSE}
vignette(all = TRUE) # list vignettes for installed packages
vignette(all = FALSE)  # vignettes from attached packages
```


How to view READMEs?

Other help...

## Objects in R

Objects (data, model output, functions)

 - Characterized by their \textbf{names} and \textbf{content}
 
 - attributes - specify the kind of data represented
    - e.g. mode, length
    
```{r, echo=TRUE}
x = 25
mode(x)
length(x)
```


## Basic data "modes" in R

The mode is the basic type of the elements of an object

The four main modes:

- numeric, comes in two flavors: integer, numeric
- character
- logical 
- complex

\small
```{r, echo=TRUE}
num = 15.533; name = "Mike"; isStudent = TRUE
```

```{r, echo=TRUE}
mode(num); mode(name); mode(isStudent)
```


## Atomic vectors

Fundamental data structure in R: 

- atomic vector - vector in which every element is of same mode

To create an atomic vector, use c() function:

```{r, echo=TRUE}
c(3.145, 2.18, 9.98e3, 0.05)
```

Example: create empty character vector of length 3 and story your full name

```{r, echo=TRUE}
vector(mode = "character", length = 3)
```


## Data types examples

3 ways to create numeric vector:

```{r , echo = TRUE}
# empty numeric vector
y1 <- numeric(6)
y1     # print y1

y2 <- vector(mode = "numeric", length = 6)
y2     # print y2

y3 <- c(5, 13.222, 2, 0.001, 77.4, 31.9)
y3     # print y3
```


## Objects in R: NA

NA means "Not Available" and it denotes missing data

\small
```{r, echo=TRUE}
c(3, 5, 9, NA, 18, 25, NA)  
```

\bigskip
\normalsize
Example: Store the vector above and remove the missing values.

\small
```{r, echo=TRUE}
#incomplete.data = 
#complete.data = incomplete.data[complete.cases(incomplete.data)]
```


## R data types/structures

Four fundamental data types:

- character, numeric (numeric or integer), logical, complex

Combine to form data structures

- atomic vector (atomic - vector of single type)
- list
- matrix
- data.frame
- factor

We will focus on matrices and data.frames

## Matrices

Matrices are the natural extension of atomic vectors into 2 dimensions

- any mode can be used, but numeric most common:

Syntax:

```{r, echo = TRUE,eval=FALSE}
m = matrix(data, nrow, ncol, byrow, dimnames)
```

- \textbf{data} is the input vector which becomes the data elements of the matrix
- \textbf{nrow, ncol} is the number of rows/columns to be created
- \textbf{byrow} is T/F. If TRUE then the input vector elements are arranged by row
- \textbf{dimnames} is the names assigned to the rows and columns

## Matrix examples:

Identity matrix:
```{r,echo=TRUE, eval=TRUE}
dat = c(1,0,0,0,1,0,0,0,1)  # data
iden = matrix(data = dat, nrow = 3, byrow = T)
iden  # print matrix
```

Easier:
```{r, echo=TRUE, eval=FALSE}
iden = diag(rep(1,3))
iden
```

## access elements of a matrix

- single brackets used to access elements

Access individual elements:

```{r, echo=TRUE}
# 2x5 matrix of numbers 1 to 10
P = matrix(data = 1:10, nrow = 2)  
P[1,3] # row 1, column 3
P[nrow(P),ncol(P)] # row 2, column 5 (bottom right position)
```

Access entire rows/columns:

```{r, echo=TRUE}
P[,3];
```

## The data.frame

The \textbf{data.frame} is the most common way to store and work with data in R

 - Not surprising: they are designed for this purpose

 - Most modeling functions work on data.frames

Composed of a list of equal length atomic vectors (can be of any type)

Exercise: 

\small The following are data on students in the class:

- \small Has Master's (logical):  TRUE FALSE FALSE TRUE
- \small GPA (numeric):           3.1  4.0   2.9   3.6
- \small First Name (character):  Mike Dan   Sara  Karen

Convert to three atomic vectors of appropriate type.

```{r, echo=TRUE, eval=FALSE}
#insert solution
```


## data.frame examples

\small Create a data.frame out of the following "class" data:

- \small Has Master's (logical):  TRUE FALSE FALSE TRUE
- \small GPA (numeric):           3.1  4.0   2.9   3.6
- \small First Name (character):  Mike Dan   Sara  Karen

```{r , echo = TRUE}
# store data
has_ms <- c(TRUE, FALSE, FALSE, TRUE)
gpa <- c(3.1, 4.0, 2.9, 3.6)
name <- c("Mike", "Dan", "Sara", "Karen")
# Create data.frame
dat <- data.frame(has_MS = has_ms, GPA = gpa, Name = name)
dat    # print data.frame
```


## access elements of a data.frame

Each vector of a data.frame contains the values of a variable

Access each vector with the dollar sign $

Ex: Extract the GPA column and print it

```{r, echo=TRUE, eval=TRUE}
dat$GPA
```

Another example: ToothGrowth data.

```{r, echo=TRUE, eval = FALSE}
ToothGrowth$len
```

Exercise: Add a new column to the data.frame dat with NAs

```{r, echo=TRUE, eval=FALSE}
# Hint: = NA will recycle NA to the appropriate length
```


## Preview data.frame

Preview head (first few rows) of data.frame:

```{r, echo=TRUE, eval=TRUE}
head(ToothGrowth)
```


View tail of data.frame:

```{r, echo=TRUE, eval=FALSE}
tail(dat)
```

View entire data.frame in new window:

```{r, echo=TRUE, eval=FALSE}
View(ToothGrowth)
```


## Inspect an object

- class() - what kind of object is it (high-level)?
\bigskip
- typeof() - what is the data type (low-level)?
\bigskip
- length() - how long is it?
\bigskip
- attributes() - does it have meta-data?
\bigskip

## Inspect an object

- class() - what kind of object is it (high-level)?
```{r, echo=TRUE}
class(ToothGrowth)
```
\bigskip
- typeof() - what is the data type (low-level)?
```{r, echo=TRUE}
typeof(ToothGrowth$supp)
```


## Inspect an object

- length() - how long is it?
```{r, echo=TRUE}
length(ToothGrowth$dose)
```
\medskip
- attributes() - does it have meta-data?
```{r, echo=TRUE}
attributes(ToothGrowth)
```


## R functions

\small R function syntax:

\small NAME <- function(ARG1, ARG2, ARG3) { \newline
\small \hspace*{20pt} DO SOMETHING \newline
\small \hspace*{20pt} STORE RESULT \newline
\small \hspace*{20pt} return(RESULT) \newline
\small }

```{r , echo = TRUE}
pow <- function(base, expon) { # power function
  prod(rep(base, expon)) # base^(expon)
}
# Use power function
pow(5, 2)
pow(10, 3)
```

## R functions: 

\small R function syntax:

\small NAME <- function(ARG1, ARG2, ARG3) { \newline
\small \hspace*{20pt} DO SOMETHING \newline
\small \hspace*{20pt} STORE RESULT \newline
\small \hspace*{20pt} return(RESULT) \newline
\small }

Exercise: Write a function that calls the pow() function and returns a list 
of base taken to the powers 2, 4, and 8.

```{r , echo = TRUE}
# Hint: create list with list(pow2 = , pow4 = , pow8 = )
```


## Common R functions

\small R has a huge collection of packages:

\small  - 6,000+ packages for data analysis build (on CRAN alone)

\small Example: lm (linear models)

\small - Use ?lm to read help documentation 

\includegraphics[width = 3in]{lm_help.PNG}

## Fit a linear model with lm

- Use built-in data set ToothGrowth

- ?ToothGrowth for help:

\includegraphics[width = 3in]{quesToothGrowth.JPG}

## View the data

\small View data in new window:
```{r, echo = TRUE,eval=FALSE}
View(ToothGrowth)
```
\bigskip
\small Or use head to view only first 6 rows:
\tiny
```{r, echo = TRUE}
head(ToothGrowth)
```
\bigskip
\small How big is the data?
\tiny
```{r, echo = TRUE}
dim(ToothGrowth)
```


## Using lm() function for linear models
Call lm on the data and formula, store result "lm" object:
```{r, echo = TRUE, eval = TRUE}
tooth_fit = lm(formula = len ~ supp + dose, 
               data = ToothGrowth)
```

Formulas in R:
```{r, echo = TRUE, eval = FALSE}
len ~      # Response column name, ~ for "="
  supp +   # First predictor name + for "+"
  dose     # second predictor name
```

Many R functions use the formula argument.

## Getting detailed information

\small
Basic "print" of model:
\tiny
```{r, echo = TRUE, eval = TRUE}
print(tooth_fit)     # equivalent to tooth_fit
```
\small
Detailed summary:
\tiny
```{r, echo = TRUE, eval = TRUE}
summary(tooth_fit)
```

## Understanding R classes

- What is this thing?
```{r, echo = TRUE, eval = FALSE}
class(tooth_fit)
```
- What are the methods for this object?
```{r, echo = TRUE, eval = FALSE}
methods(class = "lm")
```
- What is its structure? (i.e., what's in it)
```{r, echo = TRUE, eval = FALSE}
str(tooth_fit)
```

## Understanding R classes

- What is this thing?
```{r, echo = TRUE, eval = TRUE}
class(tooth_fit)
```

## Understanding R classes
\small
- What are the methods for this object?
```{r, echo = TRUE, eval = TRUE}
methods(class = "lm")
```

## Understanding R classes

\tiny
- What is its structure? (i.e., what's in it)
```{r, echo = TRUE, eval = TRUE}
str(tooth_fit)
```

## Understanding R classes

- Pull something out of the "lm" fit object:

\tiny
```{r, echo = TRUE, eval = TRUE}
tooth_fit$fitted.values        # y_hat's for the linear model
```

## Extracting data from model objects

Some generic extraction methods: 

```{r, echo = TRUE, eval = FALSE}
coef(tooth_fit)            # model coefficients

coef(summary(tooth_fit))   # adds test statistics, p-values

vcov(tooth_fit)            # variance/covariance matrix
```

Note: depending on implementation, these may not be available
- Check methods with "methods(object)" before attempting

## Extracting data from model objects (in detail)

Extract coefficients, test stats, and p-values
```{r, echo = TRUE, eval = TRUE}
coef(summary(tooth_fit))   # adds test statistics, p-values
```


## Predict new values

- predict() function is generic and works with many models

- Pass in a new data.frame with the same column names:

```{r, echo = TRUE, eval = TRUE}
to_predict = data.frame(dose = 0.5, supp = "VC")
```

```{r, echo = TRUE, eval = TRUE}
predict(tooth_fit, newdata = to_predict)
```


## Predict new values (example 2)

- predict() function is generic and works with many models

- Pass in a new data.frame with the same column names:

\small
```{r, echo = TRUE, eval = TRUE}
to_predict = data.frame(dose = seq(0,1,0.1), supp = "OJ")
```

```{r, echo = TRUE, eval = TRUE}
predict(tooth_fit, newdata = to_predict)
```

## Day 2

 - Non-interactive R and the cluster (Instructed by Dan Barker)
 
 \bigskip
 
 - How to write optimized code, including vectorization and loops, and 
 
 \bigskip
 
 - introduction to data manipulation with dplyr, and visualization with ggplot2
 
## Packages to install for today

Run the following chunk to install packages:

```{r, echo=TRUE, eval=FALSE}
install.packages("tidyverse")
```

Load into memory:

```{r, echo=TRUE, eval=FALSE}
library(tidyverse) # actually a set of packages
```


## R on cluster (non-interactive R)

\textbf{Cluster Computation}

- Dan Barker danbarke at umich.edu

\medskip

- Cluster System Administrator


## Basic workflow for statistical analysis


\includegraphics[width = 3in]{analysis_in_r2.png}


## What is the tidyverse?

 - collection of (very useful) R packages for doing "data science"
 
 - ggplot2 - for plotting, visualizing data
 
 - dplyr - for data manipulation/processing
 
 - tidyr, readr (read data), purrr (better loops), tibble (improved data.frame), stringr, forcats
 
 - Learn: R for Data Science, Grolemund and Wickham (free online)

## Advanced control structures

Common misconception: "loops in R are slow"

 - Many commenters say loops in R are a bad idea,

 - But, sometimes difficult (or impossible) to write vectorized code, or vectorized code consumes too much memory. 
 
\bigskip
 
 - We discuss:
 
   - How to improve loops when they are necessary
  
   - Eliminate them when possible

## Loops: often not necessary

 - Many R functions are "vectorized" (vector in, vector out)

 - While most other languages require loops, R does not:
 
```{r, echo = TRUE, eval = TRUE}
a = c(5, 2, 4, 12, 1)
b = c(2, 0, 3, -1, 2)

a + b     # vector + vector = vector
```

Takehome: When possible, operate on vectors and matrices, don't loop over each 
row/position index

## Problem: not all functions are vectorized

- Some functions, like read.table() for reading a table of data into R, are 
not vectorized

- But what if we have a list of files to read in? "data1.txt", "data2.txt",
"data3.txt", ..., "data50.txt"

```{r, echo = TRUE, eval = TRUE, results='hide'}
   # the 50 data set names
file_names = paste0("data", 1:50, ".txt")  
```

Attempt it, will cause error:
```{r, echo = TRUE, eval = FALSE}
read.table(file_names)  # error!
```


## map() from purrr package to avoid loop

- map() allows you to apply a function to each element of a vector

- faster, easier to read than a loop

```{r, echo = TRUE, eval = FALSE}
read.table(file_names)  # error!
```

```{r, echo = TRUE, eval = FALSE}
    # list of 50 data sets
my_dat_list = map(file_names, read.table)
    # results from reading data1.txt
my_dat_list[[1]]     
    # results from reading data50.txt
my_dat_list[[50]]       
```

## Create your own functions for map

Generate random samples from a Normal with different variances

```{r, echo = TRUE, eval = FALSE}
draws = map(2:20, function(x) rnorm(25, mean=0, sd=x))
# returns a list with vectors of draws
str(draws)
# first vector of draws:
draws[[1]]

# last vector of draws:
draws[[19]]
```

## Create your own functions for map

Now, estimate the standard error:

```{r, echo = TRUE, eval = FALSE}
map(draws, sd)  # sd() is standard deviation in R

map_dbl(draws, sd) # numeric vector
```

## For loop vs map() version

- Standard for loop:

```{r, echo = TRUE, eval = FALSE}
sdvs = 2:20; result.list = list(length = 19)
for (i in 1:19) {
  result.list[[i]] = rnorm(25, mean=0, sd=sdvs[i])
}
```

- map():

```{r, echo = TRUE, eval = FALSE}
map(2:20, function(x) rnorm(25, mean=0, sd=x))
```

Advice: If you're tracking indexes (like with the for loop), consider re-writing so you no longer have to depend on correct indexing

## Sometimes loops are required

Sometime you just need loops:

- Growth model, new values depend on previous values

```{r, echo = TRUE, eval = FALSE}
N = 20
for (i in 2:30) {
  f = rpois(1, 0.15*N[i-1])   # births
  d = rbinom(1, N[i-1], 0.1)  # deaths
  N[i] = N[i-1] + f - d
}

plot(seq_along(N), N)
```

Execute the code to see our simulated growth curve

## Problem: Growing objects is slow

```{r, echo = TRUE, eval = FALSE}
N = 20
for (i in 2:30) {
  f = rpois(1, 0.15*N[i-1])   # births
  d = rbinom(1, N[i-1], 0.1)  # deaths
  N[i] = N[i-1] + f - d       # alive
}

plot(seq_along(N), N)
```

- Our growth model loop is slow because we are growing a vector at each iteration

- Solution pre-allocate vector (or any data type), then fill with loop

## Efficient memory usage 

Improved code:

```{r, echo = TRUE, eval = FALSE}
# Pre-allocate to correct size
N = vector(mode = "numeric", length = 30)
N[1] = 20
for (i in 2:30) {
  f = rpois(1, 0.15*N[i-1])   # births
  d = rbinom(1, N[i-1], 0.1)  # deaths
  N[i] = N[i-1] + f - d       # alive
}

plot(seq_along(N), N)
```

 - In this simple example, does not make a difference
 
 - With real-world, it will make a difference

## overview of loops

- Do not do things inside a loop that can be done outside

- Use vectorized functions whenever possible

- Map when function is not vectorized
  - Avoids the need to track indexes
  - Does the pre-allocation for you

- If you use loops, avoid growing lists/collections/data.frames
  - pre-allocate memory
  
  
## tidyverse

\Large
Brief introduction to programming with tidyverse

\includegraphics[width = 3.5in]{tidyverse.png}

## dplyr

Motivation:

 - Analysts spend a lot of time manipulating and summarizing data
 
 - Base R provides many functions for this, BUT:
   - the syntax is ugly
   - the functions can be slow/inefficient
   
 - dplyr exists to make data manipulation easy to follow/correct/fast
 
## Install and load dplyr

 - ggplot is included in the tidyverse package. To load the tidyverse package, 
 run 
```{r, echo = TRUE, eval = TRUE, message=FALSE}
library(tidyverse)
```

 - If you get the message "there is no package 'tidyverse' " you must install it first:
 
```{r, echo = TRUE, eval = FALSE}
install.packages("tidyverse")
library(tidyverse) # now load the tidyverse package
```

## Sample data set

 - We will be using a data set containing all out-bound flights from NYC in 2013
 
 - Available as an R package
 
```{r, echo = TRUE, eval = TRUE, message=FALSE}
#install.packages("nycflights13")
library(nycflights13)
#View(flights)
```

## nycflights13 tables

Multiple data sets in this "package" of data related to the NYCflights:

\includegraphics[width = 3.5in]{nycflights13.JPG}

## "flights" table 

Preview the flights data: 
\tiny
```{r}
flights
```

## dplyr verbs

dplyr provides a cogent, systematic way to carry out most data manipulation tasks:

These functions, called "verbs" are:

 - filter() - keep rows matching desired properties
 - select() - choose which columns you want to extract
 - arrange() - sort rows
 - mutate() - create new columns
 - summarize() - collapse rows into summaries
 - group_by() - operate on subsets of rows at a time
 

## dplyr verb properties

 - Always take data set as the first parameter
 - Returns a new data object, never updates/replaces original
 - Specify columns as unquotes strings (symbols)
 - use "pipes" (%>%) to pass result of one call on to the next
   - %>% operator passes the result of the left side to the first arg. on right
   - a(b(c(x))) equals x %>% c() %>% b() %>% a()

Example: 

```{r, echo=TRUE, eval=FALSE}
flights %>%                 # data
  filter(carrier == "AA")   # apply verb
```

## Filtering rows

 - Find all flights to Detroit (DTW) in June (2013)
 - Use filter() to complete the task
 
```{r, echo=TRUE, eval=FALSE}
flights %>%                 # data
  filter(carrier == "AA" & month == 6)   # filter DTW as dest.
```

Equivalently:

```{r, echo=TRUE, eval=FALSE}
flights %>%                 # data
  filter(carrier == "AA") %>%  # filter DTW as dest.
  filter(month == 6)           # On the DTW data, filter only June
```

## Selecting columns 

- To select specific columns, send a comma separated list of unquoted names

Select specific columns:

```{r, echo=TRUE, eval=FALSE}
flights %>% 
  select(dep_time, arr_time, carrier)
```


Exclude specific columns:

```{r, echo=TRUE, eval=FALSE}
flights %>% 
  select(-year, -tailnum)
```


Select range of columns:

```{r, echo=TRUE, eval=FALSE}
flights %>% 
  select(month:dep_delay)
```

## Selecting columns: Part 2

```{r, echo=TRUE, eval=FALSE}
flights %>% select(starts_with("d"))

flights %>% select(ends_with("time"))

flights %>% select(contains("arr"))

flights %>% select(-starts_with("d"))
```

See "?select" for complete list and examples

## Sort data

 - Use arrange() to sort your rows
 
```{r, echo=TRUE, eval=FALSE}
flights %>% arrange(sched_dep_time)
```

 - Use desc() to reverse the sort order of a column

```{r, echo=TRUE, eval=FALSE}
flights %>% arrange(month, desc(day))
```

 - You can sort on functions of variables

```{r, echo=TRUE, eval=FALSE}
flights %>% arrange(desc(dep_time-sched_dep_time))
```


## Create new variables

 - Mutate allows you to create columns using existing values
 
```{r, echo=TRUE, eval=FALSE}
flights %>% 
  mutate(speed = distance/(air_time/60)) %>% 
  arrange(desc(speed)) %>% 
  select(flight, speed)
```

 - Remember, changes are not saved to "flights", be sure to save the result if 
 you want to use it later
 
```{r, echo=TRUE, eval=FALSE}
new_flights <- flights %>% mutate(…)
```
 
## Use new variables right away

 - The parameters to mutate are processed in the order they appear
   - You can use new variables right away

```{r, echo=TRUE, eval=FALSE}
flights %>% 
  mutate( dist_km = distance * 1.61, 
          hours = air_time / 60, 
          kph = dist_km/hours ) %>% 
  select(flight, kph)
```

 - Be careful! You can overwrite existing variables
 
## Summarize data

 - You generally use summarize() to reduce the number of rows in your data by specifying summary functions for each of the columns
 
```{r, echo=TRUE, eval=FALSE}
flights %>% 
  filter(!is.na(arr_delay)) %>% 
  summarize(avg_arr_delay = mean(arr_delay))
```

 - Most useful summary functions:
   - mean(), median(), var(), sd(), min(), max(), first(), last(), 
   n(), n_distinct()


## Summarize data

 - Most useful summary functions:
   - mean(), median(), var(), sd(), min(), max(), first(), last(), 
   n(), n_distinct()
   
 - exercise: create one statement to calculate the mean and standard deviation
 for the departure delay (dep_delay()) column
 
```{r, echo=TRUE, eval=FALSE}


```


## Grouping data

 - Often you want to perform summaries for groups of rows at a time 
 
 - group_by() function allow you to specify columns that define groups
 
 - Functions like mutate() and summarize() are then performed for each group
 
## group_by() + summarize() example

 - Find the average arrival delay for each carrier, where all the missings are 
 removed from arr_delay

```{r, echo=TRUE, eval=FALSE}
flights %>%
  filter(!is.na(arr_delay)) %>% 
  group_by(carrier) %>%
  summarize(avg_arr_delay = mean(arr_delay))
```

 - Exercise: Improve the summary above to only include airlines with a negative mean
 arrival delay, i.e. the flights are early, on average
 
```{r, echo=TRUE, eval=FALSE}

```


## Some special shortcuts

 - count()
   - count number of rows with unique values of selected columns
```{r, echo=TRUE, eval=FALSE}
flights %>% count(carrier)
```

 - summarize_all()/mutate_all()
   - apply function to all columns

```{r, echo=TRUE, eval=FALSE}
flights %>% 
  summarize_all(mean, na.rm=T)
```

 - summarize_at()/mutate_at()
   - apply function to chosen columns

```{r, echo=TRUE, eval=FALSE}
flights %>% 
  summarize_at(vars(ends_with("time")), mean, na.rm=T)
```

## Summarization exercises

 - What month received the most number of flights to your home/favorite airport?
 
 - What is the average airspeed for all flights?
 
 - What was the average departure delay (for flights that actually had a departure)?
 
 - What was the longest delay for each carrier (which carrier had the longest 
 delay for a single flight)?


## Combining data frames

 - bind_rows()
   - Stack two data frames on top of each other (should have the same number 
   of columns)

 - bind_columns() 
   - Place two data frames next to each other (should have the same number of 
   rows) – no merge-able columns 
   
 - intersect(), union(), setdiff()
   - For rows shared or exclusive to data frames

## ggplot2

 - Even though the package is sometimes just referred to as "ggplot", 
 the package name is "ggplot2"
 
 - ggplot is included in the tidyverse package. To load the tidyverse package, 
 run 
```{r, echo = TRUE, eval = FALSE}
library(tidyverse)
```

 - If you get the message "there is no package 'tidyverse' " you must install it first:
 
```{r, echo = TRUE, eval = FALSE}
install.packages("tidyverse")
library(tidyverse) # now load the tidyverse package
```

## ggplot2 help

 - Use the R help with 

```{r, echo = TRUE, eval = FALSE}
?ggplot
```

 - Use the website:  http://ggplot2.tidyverse.org/reference/ 
 
 - Read Hadley's book (ggplot2: Elegant graphics for data analysis)
 
## Gapminder Data

 - Dataset tracking life expectancy and per-capita GDP of 142 countries
 
 - Data reported every five years from 1952-2007
 
 - Data set is available in R package on CRAN:
   - install.packages("gapminder")

\bigskip

```{r, echo = TRUE, eval = TRUE, message=FALSE}
#install.packages("gapminder")
library(gapminder)
#View(gapminder)    # check out the data, scroll through it
```

## Create scatterplot

 - Interest in how life expectancy relates to GDP per capita
   - Does life expectancy increase with per capita GDP?

\bigskip

 - Create a scatterplot of gdpPercap (Y-axis) vs lifeExp (X-axis)
 
\bigskip

```{r, echo = TRUE, eval = TRUE, fig.height = 1.5, fig.width = 2.5}
ggplot(data = gapminder, aes(x=gdpPercap, y=lifeExp)) + 
  geom_point(size = 0.5)
```


## Add some color

```{r, echo = TRUE, eval = TRUE, fig.height = 1.5, fig.width = 2.5}
ggplot(data = gapminder, aes(x=gdpPercap, y=lifeExp)) + 
  geom_point(size = 0.5, color = "blueviolet")
```
  
 - Check out the color names that R knows:
```{r, echo = TRUE, eval = FALSE}
colors()
```
 - Can also take HEX values, e.g. "#8A2BE2"


## Color by the data

Incorporate color into the plot in a useful way:

 - Color by continent to see trends by region of the world
 
\tiny
```{r, echo = TRUE, eval = TRUE, fig.height = 1.5, fig.width = 3.5}
ggplot(data = gapminder, aes(x=gdpPercap, y=lifeExp, color = continent)) + 
  geom_point(size = 0.5)
```


## Scale point size by data

 - Make countries with larger populations have larger dots
   - How big are the high GDP countries?

\tiny
```{r, echo = TRUE, eval = TRUE, fig.height = 1.5, fig.width = 3.5}
ggplot(data = gapminder, aes(x=gdpPercap, y=lifeExp, color = continent, size = pop)) + 
  geom_point()
```

## Geometries

 - geom_point() is just one of many geometries:
   - Used to make scatter plots
   - Works best with two continuous variables
  
 - What if we wanted to look at a distribution of a single continuous variable?

\tiny
```{r, echo = TRUE, eval = TRUE, fig.height = 1.5, fig.width = 3.5}
ggplot(data = gapminder, aes(x=lifeExp)) + 
  geom_histogram()  # function for histograms
```


## Geometries

 - geom_point() is just one of many geometries:
   - Used to make scatter plots
   - Works best with two continuous variables
  
 - What if we wanted to look at a distribution of a single continuous variable?

\tiny
```{r, echo = TRUE, eval = TRUE, fig.height = 1.5, fig.width = 3.5}
ggplot(data = gapminder, aes(x=lifeExp)) + 
  geom_density()  # function for smoothed density
```


## Density plot with custom aesthetics

 - Add color fill 
 
\tiny
```{r, echo = TRUE, eval = TRUE, fig.height = 1.5, fig.width = 3.5}
ggplot(data = gapminder, aes(x=lifeExp)) + 
  geom_density(fill = "firebrick")  # function for smoothed density
```

## Single variable across groups

 - Plot density over life expectancies by continent
   - Fill contients with their own color to distinguish them
   
```{r, echo = TRUE, eval = TRUE, fig.height = 1.5, fig.width = 3.5}
ggplot(data = gapminder, aes(x=lifeExp, fill = continent)) + 
  geom_density(alpha = 0.2)  # function for smoothed density
```

## Single variable across groups

 - Another approach to the same problem:
   - Use boxplots to characterize differences across groups
   
```{r, echo = TRUE, eval = TRUE, fig.height = 1.5, fig.width = 3.5}
# Notice how aes change
ggplot(data = gapminder, aes(x=continent, y = lifeExp)) + 
  geom_boxplot()
```


## Single variable across groups

 - Violin plot:
 
```{r, echo = TRUE, eval = TRUE, fig.height = 1.5, fig.width = 3.5}
# Notice how aes change
ggplot(data = gapminder, aes(x=continent, y = lifeExp)) + 
  geom_violin()
```


## Stack geometries in layers

 - How can we display the plot with data overlay?
 
```{r, echo = TRUE, eval = TRUE, fig.height = 1.5, fig.width = 3.5}
# Notice how aes change
ggplot(data = gapminder, aes(x=continent, y = lifeExp)) + 
  geom_violin() + 
  geom_jitter(alpha = 0.2)  # jitter the points
```

## Simulation Basics

Why simulate?

  - confirm model/method works by mimicking the real world

Sampling in R from sets and distributions:

Simulate a coin toss experiment:

  - toss a coin ten times, record what side it lands on each time
  
\small
```{r, echo=TRUE}
set.seed(7794)
sample(c("H","T"), size = 10, replace = TRUE) # fair coin
sample(c("H","T"), size = 10, replace = TRUE, 
                         prob = c(0.6, 0.4)) # weighted coin
```

## Simulation Basics

Sampling in R from distributions:

 - d___(x) returns the density of a probability distribution for a discrete value of x
 
 - p___(q) returns the cumulative density function (CDF) up to q
 
 - q___(p) returns the quantile from a cumulative probability
 
 - r___(n) returns a random deviate (a simulation of random draw) of size n

\small
Example:
```{r, echo=TRUE}
qnorm(0.025); dnorm(0)
```

?distributions for more information

## Simulation

\begin{table}
\begin{tabular}{l | l}
distribution & function \\
\hline \hline
Normal & norm(n, mean=0, sd=1) \\ 
exponential & exp(n, rate=1) \\ 
uniform & unif(n, min=0, max=1) \\
gamma & gamma(n, shape, scale=1) \\ 
poisson & pois(n, lambda) \\
Weibull & weibull(n, shape, scale=1) \\
Cauchy & cauchy(n, location=0, scale=1) \\
beta & beta(n, shape1, shape2) \\
Student t & t(n, df) \\
binomial & binom(n, size, prob) \\
logistic & logis(n, location=0, scale=1)
\end{tabular}
\caption{Built-in distributions}
\end{table}

## Simulation: sample from probability distributions

```{r, echo=TRUE, eval=FALSE}
rnorm(6) # 6 standard normal deviates
rnorm(10, mean=50, sd=19) # set mean and spread
runif(10, min=0, max=1) # uniform distribution
rpois(10, lambda=15) # Poisson 
```
\bigskip
Cointoss reframed: toss coin 8 times using binomial distribution

```{r, echo=TRUE, eval=FALSE}
set.seed(7794)
rbinom(8, size=1, p=0.5) # 8 coin tosses
```

## Some simple simulations 

Problem: predict the number of girls in 400 births in a population where prob.
of female birth is 48.8%

```{r, echo=TRUE}
#set.seed()
n.girls = rbinom(n=1, size=400, prob=0.488)
n.girls
```

 - Get a distribution of the number of female births when prob. = 0.488
 
```{r, echo=TRUE, eval=FALSE}
n.sims=1000
n.girls=rbinom(n.sims,400,0.488)
hist(n.girls)
```
 

## Simulation: Confidence intervals

Open simulations.R script in course files

\bigskip

Exercise: Is the coverage rate of confidence intervals for the mean accurate?

 - Given conditions similar to ours, does our method for generating confidence intervals capture the true value 95% of the time?

\includegraphics[width = 3in]{CI_coverage_example.JPG}

## Replicate for repeating simulations

Function to simulate the mean of 100 standard normal draws:

```{r, echo=TRUE, eval=FALSE}
sim.mean = function() { mean(rnorm(100)) }
```
\medskip
The following for loop repeats the simulation 1,000 times:

```{r, echo=TRUE, eval=FALSE}
sims = vector(mode = "numeric", length = 1000L)
for(i in 1:1000) { sims[i] = sim.mean() }
```
\medskip
We can avoid the for loop with \textbf{replicate()}:

```{r, echo=TRUE, eval=FALSE}
sims = replicate(1000, sim.mean())
```

## Open the simulation exercises

 - Go to course file and open the simulation exercises
 
 - Skip the reading for now, do the problems in order
 
 - Recommendation: for each solution you produce,
 
```{r, echo = TRUE, eval = FALSE}
sim = replicate(1000,
                {
                  isert simulation here
                })

hist(sim) 
```

 - this will indicate if you solution is biased (ie trends away from the true value, which I give you)

